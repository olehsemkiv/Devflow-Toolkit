---
title: Module Contract
description: Єдині правила для всіх JS/CSS модулів у наших Webflow-проєктах.
---

# Module Contract

Ця сторінка визначає правила, за якими ми будуємо будь-який модуль (Modal, Accordion, Plyr тощо). Мета: **реюз**, **передбачуваність**, **легкий дебаг**.

---

## 1) Принципи

- **Модуль працює через `data-rs-*` атрибути**, а не через жорсткі CSS класи.
- **Стани через `is-*` класи** (наприклад `is-open`, `is-active`, `is-loading`).
- Мінімум залежностей. Якщо потрібна бібліотека — чітко описати (версія + де підключається).
- Модуль має бути **safe-to-run multiple times** (повторна ініціалізація не ламає сторінку).
- Модуль має мати **публічні точки керування** (init / destroy за потреби).

---

## 2) Неймінг атрибутів

### Обовʼязкові правила
- Префікс завжди: `data-rs-...`
- Ключі **kebab-case**: `data-rs-modal-open`, `data-rs-accordion-item`
- Значення:
  - `true/false` — тільки якщо реально потрібно
  - селектори — через значення (наприклад `data-rs-modal-target="#myModal"`)

### Приклади
- Open trigger: `data-rs-modal-open`
- Target selector: `data-rs-modal-target="#modal-1"`
- Close trigger: `data-rs-modal-close`
- Accordion root: `data-rs-accordion`
- Accordion item: `data-rs-accordion-item`

---

## 3) Стани (state classes)

### Правило
**Модуль сам керує тільки `is-*` класами** на конкретних елементах.

Приклади:
- `is-open` — відкрите
- `is-active` — активний елемент/таб
- `is-disabled` — неактивний (не клікабельний)
- `is-loading` — йде процес

---

## 4) Підключення в Webflow

### Рекомендований варіант
- Скрипти підключаємо **перед `</body>`**
- Використовуємо `defer`, якщо скрипт у `<head>`
- Один “bootstrap/init” файл, який викликає ініціалізацію модулів

### Базовий bootstrap (псевдо)
- Очікуємо `DOMContentLoaded`
- Запускаємо `initModal()`, `initAccordion()` тощо
- В ідеалі підтримуємо ре-ініт після AJAX/динамічного рендеру (якщо потрібно)

---

## 5) Ініціалізація

Кожен модуль повинен мати:
- `init()` — знаходить елементи по `data-rs-*` і підвішує події
- (опціонально) `destroy()` — прибирає лісенери, якщо модуль може підключатися/відключатися динамічно

### Важливо
- Не створюємо дубль-лісенери при повторному `init()`
  - або ставимо guard (`data-rs-initialized="true"`)
  - або використовуємо делегування подій на `document`

---

## 6) Події (Events)

Для великих модулів бажано диспатчити CustomEvent, щоб інші частини сайту могли реагувати без хардкоду.

Приклад неймінгу:
- `rs:modal:open`
- `rs:modal:close`

Ціль: “склеювати” модулі між собою (Modal + Plyr, Modal + Form, тощо).

---

## 7) Accessibility baseline

Мінімум для інтерактивних модулів:
- Keyboard support (Enter/Space де потрібно)
- `Esc` для закриття (для модалок)
- focus management для модалок (повернення фокусу на тригер)
- aria-атрибути там, де логічно (accordion, tabs)

---

## 8) Debug / Logs

У модулі допускаються `console.log()` під прапором/умовою:
- або `window.RS_DEBUG = true`
- або `data-rs-debug` на `<html>`

Ціль: швидко дебажити на проєктах без переписування коду.

---

## 9) Versioning & Changelog

- Версії: `MAJOR.MINOR.PATCH`
  - PATCH: багфікси без зміни API
  - MINOR: нові фічі без лому API
  - MAJOR: ламаємо API/markup/атрибути
- Кожен реліз — короткий changelog (що змінилось, що мігрувати)

---
